%function [Dim,DimR, Wout,Tvc, Proof]=Proof_lemma_2_5(m,accuracy)
function [Proof]=Proof_lemma_2_5(m)


%% USAGE:   
%%          [Dim, DimR,Wout,Tvc]=Proof_lemma_2_5(m,accuracy);  
%%                    d=m[1],e=m[2] integer number associated with x^d+y^e
%%                         accuracy is the round order: 10^{-accuary}=0     
%% PURPOSE: 
%%          1) Compute the dimension of the homology group of the regular
%%          fiber; the number of different eigenvalues; the rank of
%%          the subspace  spanned by the monodromy action of the
%%          fibration given by f:=x^d+y^e acting on each vanishing cycle
%%          v_l==(0 0... 0 1 0...0).
%%          2) Compute a bases for these subspace for each vanishin cycles.
%%          3) Compute the thoeric subsapce stated in lemma 2.5 for each     
%%          vanishing cycle.
%%          4) Proof of lemma 2.5 for d,e  given.
%% RETURN:  
%%          - Dim(1): is the dim of the homology, i.e.N=(e-1)*(d-1).
%%            Dim(2): is the number of different eigenvalues.
%%          - DimR(l): The rank of the orbit of v_l.my 
%%          - Wout(:,:,l): is the  subspace generated by the monodromy 
%%            action on the vanisihg cycle v_l.
%%          - Tvc(:,:,l): is the theoric subsapce stated in lemma 2.5 for
%%            the vansihing cycle v_l.
%%          - Proof: It is 1 if the subpsacein Tvc(:,:,l) is contained
%%            in Wout(:,:,l) for all l. It is 0 in other case.
%% NOTE:
%%          If all critical values are different, then the rank of 
%%          Wout(:,:,l) is equal to the dimension of the Krylov space 
%%          Else, Wout and Tvc are returned with 0. 
%% SEE ALSO: 
%%          MonMatrix, VanCycleSub
%% EXAMPLE_: 
%%           [Dim,DimR, Wout,Tvc, Proof]=Proof_lemma_2_5(6,4)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Computing the intersection matrix.
Im=MonMatrix(m,1);    

%% Computing the Krylov space dimension
[U, Diag]=eig(Im);
Diag=unique(round(diag(Diag),10));  %%%% Different eigenvalues of the Intersection matrix
Dim=length(Diag);



%%%%%%%%
d=m(1); e=m(2);
N=(e-1)*(d-1);
%[Dim0,Wout]=VanCycleSubV1([d,e],accuracy); %% Compute the suspace generated for x^d+y^e
%Tvc=zeros(size(Wout));
    
%% The next matrix save the information about the eigenvalues for any degree.
%Dim(1)=N;  %% First colum, the degree
%Dim(2)=Dim0; %% Second column, if the eigevalues are different
 

%%% Proof of Lemma 2.5
if N==Dim %% If the eigenvalues are different
   Proof_for_d=1;   %%%%This is the product os logic sentence for any degre d.
   for l=1:N 
       %if mod(l,100)==0 
         %  l
       %end
        %% First we identify the column and the row in the Dynkin diagram
        colj=ceil(l/(e-1));
        rowi=mod(l,(e-1)); if rowi==0 rowi=e-1; end
        p=gcd(d,colj);
        r=gcd(e,rowi);

        %% Theoreic Vanishing cycles in the subspaces generated. They are in the columns of the Dynkin diagram, rn with n=1...d/r-1
        Tvci=zeros(N,1);   %% Conditions by fixing i
        Cont=1;
        for mm=1:d/p-1
            %% v_{i,mp}
            Dij=(mm*p-1)*(e-1)+rowi; % from ij to position in the Dynkin
            Tvci(Dij,Cont)=1;
            Cont=Cont+1;
        end

        for kk=1:p-1
             %% v_{i,mp-k}+v_{i,mp+k}
             Dij=((colj-kk)-1)*(e-1)+rowi; % from ij to position in the Dynkin
             Tvci(Dij,Cont)=1; 
             Dij=((colj+kk)-1)*(e-1)+rowi; % from ij to position in the Dynkin
             Tvci(Dij,Cont)=1; 
             Cont=Cont+1;

             %% v_{i-1,mp-k}+v_{i-1,mp+k}+v_{i+1,mp-k}+v_{i+1,mp+k}
             Dij=((colj-kk)-1)*(e-1)+(rowi-1); % from ij to position in the Dynkin
             if rowi-1<e && rowi-1>0 Tvci(Dij,Cont)=1; end
             Dij=((colj+kk)-1)*(e-1)+(rowi-1); % from ij to position in the Dynkin
             if rowi-1<e && rowi-1>0 Tvci(Dij,Cont)=1; end
             Dij=((colj-kk)-1)*(e-1)+(rowi+1); % from ij to position in the Dynkin
             if rowi+1<e && rowi+1>0 Tvci(Dij,Cont)=1; end
             Dij=((colj+kk)-1)*(e-1)+(rowi+1); % from ij to position in the Dynkin
             if rowi+1<e && rowi+1>0 Tvci(Dij,Cont)=1; end
             Cont=Cont+1;
        end


        Tvcj=zeros(N,1);   %% Conditions by fixing j
        Cont=1;
        for nn=1:e/r-1
            %% v_{nr,j}
            Dij=(colj-1)*(e-1)+nn*r; % from ij to position in the Dynkin
            Tvcj(Dij,Cont)=1; Cont=Cont+1;
        end
        for ll=1:r-1
             %% v_{nr-l,j}+v_{nr+l,j}
             Dij=(colj-1)*(e-1)+(rowi-ll); % from ij to position in the Dynkin
             Tvcj(Dij,Cont)=1;
             Dij=(colj-1)*(e-1)+(rowi+ll); % from ij to position in the Dynkin
             Tvcj(Dij,Cont)=1; Cont=Cont+1;

              %% v_{nr-l,j-1}+v_{nr+l,j-1}+v_{nr-l,j+1}+v_{nr+l,j+1}
             Dij=((colj-1)-1)*(e-1)+(rowi-ll); % from ij to position in the Dynkin
             if colj-1<d && colj-1>0 Tvcj(Dij,Cont)=1; end
             Dij=((colj-1)-1)*(e-1)+(rowi+ll); % from ij to position in the Dynkin
             if colj-1<d && colj-1>0 Tvcj(Dij,Cont)=1; end
             Dij=((colj+1)-1)*(e-1)+(rowi-ll); % from ij to position in the Dynkin
             if colj+1<d && colj+1>0 Tvcj(Dij,Cont)=1; end
             Dij=((colj+1)-1)*(e-1)+(rowi+ll); % from ij to position in the Dynkin
             if colj+1<d && colj+1>0 Tvcj(Dij,Cont)=1; end
        end


       %%%% Choosing the vanishing cycles described in Lemma 2.5
       Tlvc=[Tvci Tvcj]; %%% The union of two conditions
       
       %%%% The solutions of U*x=Tlvc
       W=U\Tlvc;    
       %% U*x=Tlvc(:,1) are the generators Krylov sub. of vl
        aW=abs(W); %% The norm of W
       Rzeros=-round(log10(max(aW(:,1))))+3; %% The order of rounding to zero
       if Rzeros <4
           Rzeros=4;
       end
      
       [IndR, IndC]=find(round(aW(:,:),Rzeros)~=0); %% The coeff. different to 0
       Proof_for_vl=1;
       if length(IndR(IndC==1))~=N
           for k=1:size(Tlvc,2)
               Proof_for_vl=Proof_for_vl*prod(ismember(IndR(IndC==k),IndR(IndC==1)));
           end
       end
       Proof_for_d=Proof_for_d*Proof_for_vl;
   end
   Proof=Proof_for_d;
else %% If there are eigenvalues with multiplicity bigger than 1
   Proof=0;
end
         